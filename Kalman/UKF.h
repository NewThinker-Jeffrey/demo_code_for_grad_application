#ifndef UKF_H
#define UKF_H

#include "Kalman/Kalman.h"
#include "MathToolsCpp/Matrix.h"

START_JK_KALMAN

enum NoiseType {

    // noise only include additive components ;
    PureAdditive_Noise,

    // noise only include non-additive components ;
    NonAdditive_Noise,

    // noise with non-additive and additive parts , and the
    // two parts are independent on each other.
    // the components of the noise are aligned into two column
    // matrices, with the one filled by the additive components
    // and the other by non-additive ones.
    // so there are two covariation matrices too .
    Heterogeneous_Noise

};



class UKF
{
public:
    struct Model ;
    struct NoiseDescrip ;

    UKF (Float alpha=0.001, Float beta=2, Float kappa=0) ;
    ~UKF() ;
    bool update(Model& model, const Matrix& Y, const Matrix& U=Matrix()) ;
    bool predict(Model& model, const Matrix& U=Matrix()) ;


    Float kappa ;
    Float alpha ;
    Float beta  ;
    bool timePrint ;

public : // some useful functions
    static Matrix CholeskySR(const Matrix& A, int cols=0) ;
    static Matrix LDLT_SR(const Matrix& A, int cols=0) ;
    static Matrix ProjectCovX (const Matrix& CovX, const Matrix& OthoSpace);
protected:
    bool checkDimension(Model& model) ;
    bool update(Model& model, const Matrix& Y, const Matrix& U, bool withMeasurement) ;
};


struct UKF::NoiseDescrip {

    NoiseType type ;

    Matrix additiveCov ;
    Matrix SR_additiveCov ;

    Matrix nonAdditiveCov ;
    Matrix SR_nonAdditiveCov ;
} ;


struct UKF::Model {

public:
    ///////////////////////////////////////////////////////////////////
    // 'nonAdditive_Vk' is the non-additive part of the process noise.
    // 'nonAdditive_Nk' is the non-additive part of the measure noise.
    ///////////////////////////////////////////////////////////////////
    virtual Matrix f(const Matrix& Xk, const Matrix& Uk=Matrix(),
                     const Matrix& nonAdditive_Vk=Matrix()) = 0;
    virtual Matrix h(const Matrix& Xpre, const Matrix& nonAdditive_Nk=Matrix()) = 0;

public:
    Model() ;
    virtual ~Model() ;

    virtual bool setPosterior(const Matrix& X, const Matrix& Pxx) ;
    const PosteriorStatus& getPosterior() const ;
    Matrix getStatus() const ;


    ///////////////////////////////////////////////////////////////////
    // for the problems involving nonlinear manifold (i.e. either the
    // status space or the measurement space is a nonlinear manifold,
    // or both of them are nonlinear manifolds), we simplify them
    // into normal ones ,in which UKF can be approximately applied, by mapping
    // the points in the manifold to a neighborhood tangent-space. However,
    // this method only works when the manifold is not of super nonlinear .
    //
    // an instance of class ManifoldMap substantialize a mapping between a manifold
    // and its tangent spaces.
    // when the Model's destructor is called, the input 'Map' will be deleted. so the
    // input 'Map' should be generated by C++operator 'new'.
    ///////////////////////////////////////////////////////////////////
    bool setStatusMap(ManifoldMap* Map) ;
    const ManifoldMap* getStatusMap() const ;
    bool setMeasureMap(ManifoldMap* Map) ;
    const ManifoldMap* getMeasureMap() const ;


    ///////////////////////////////////////////////////////////////////
    // ** in case 'type=PureAdditive_Noise' or 'type=NonAdditive_Noise',
    // 'Q' is the corresponding covariation, 'Q2' is ignored ;
    // ** in case 'type=Heterogeneous_Noise', 'Q' is the additive and
    // 'Q2' is the non-additive covariation ;
    //
    // if the status space is a nonlinear manifold, the most recommended
    // option for typeQ is NonAdditive_Noise ; because the tangent space
    // where additive options apply is totally undetermined before calclation.
    ///////////////////////////////////////////////////////////////////
    bool setQ(const Matrix& Q, NoiseType type=PureAdditive_Noise, const Matrix& Q2=Matrix()) ;

    ///////////////////////////////////////////////////////////////////
    // ** in case 'type=PureAdditive_Noise' or 'type=NonAdditive_Noise',
    // 'R' is the corresponding covariation, 'R2' is ignored ;
    // ** in case 'type=Heterogeneous_Noise', 'R' is the additive and
    // 'R2' is the non-additive covariation ;
    //
    // if the measurement space is a nonlinear manifold, the most recommended
    // option for typeR is NonAdditive_Noise ; because the tangent space
    // where additive options apply is totally undetermined before calclation.
    ///////////////////////////////////////////////////////////////////
    bool setR(const Matrix& R, NoiseType type=PureAdditive_Noise, const Matrix& R2=Matrix()) ;

protected:
    // the default method to get the square root of a matrix is LDL decomposition.
    // once you have an alternate, reimplement the virtual method below.
    virtual Matrix SR(const Matrix& A, int cols=0) ;


    ///////////////////////////////////////////////////////////////////
    // typeQ() returns the noise type, which qualify the additive and non-additive
    // parts, of the process noise ;
    // dimensionAdditiveQ() returns the number of the additive components in the
    // process noise, while dimensionNonAdditiveQ() returns that of  the non-additive;
    // dimensionQ() returns the total components in the process noise,
    // including both additive and non-additive parts.
    ///////////////////////////////////////////////////////////////////
    NoiseType typeQ() const;
    int dimensionAdditiveQ() const ;
    int dimensionNonAdditiveQ() const ;
    int dimensionQ() const ;

    ///////////////////////////////////////////////////////////////////
    // typeR() returns the noise type, which qualify the additive and non-additive
    // parts, of the measure noise ;
    // dimensionAdditiveR() returns the number of the additive components in the
    // measure noise, while dimensionNonAdditiveR() returns that of  the non-additive;
    // dimensionR() returns the total components in the measure noise,
    // including both additive and non-additive parts.
    ///////////////////////////////////////////////////////////////////
    NoiseType typeR() const;
    int dimensionAdditiveR() const ;
    int dimensionNonAdditiveR() const ;
    int dimensionR() const ;


    ///////////////////////////////////////////////////////////////////
    // ** in case 'typeQ()=NonAdditive_Noise',
    // nonAdditiveQ() returns the covariation matrix of the non-additive process noise,
    // SR_nonAdditiveQ() is nonAdditiveQ()'s square root ;
    // additiveQ() and SR_additiveQ() make no sense.
    // ** in case 'typeQ()=PureAdditive_Noise':
    // additiveQ() returns the covariation matrix of the additive process noise,
    // SR_additiveQ() is additiveQ()'s square root ;
    // nonAdditiveQ() and SR_nonAdditiveQ() make no sense.
    // ** in case 'typeQ()=Heterogeneous_Noise':
    // nonAdditiveQ() returns the covariation matrix of the non-additive process noise,
    // SR_nonAdditiveQ() is nonAdditiveQ()'s square root;
    // additiveQ() return the covariation matrix of the additive process noise,
    // SR_additiveQ() is additiveQ()'s square root ;
    ///////////////////////////////////////////////////////////////////
    Matrix additiveQ() const;
    Matrix nonAdditiveQ() const;
    Matrix SR_additiveQ() const;
    Matrix SR_nonAdditiveQ() const;


    ///////////////////////////////////////////////////////////////////
    // ** in case 'typeR()=NonAdditive_Noise',
    // nonAdditiveR() returns the covariation matrix of the non-additive process noise,
    // SR_nonAdditiveR() is nonAdditiveR()'s square root ;
    // additiveR() make no sense.
    // ** in case 'typeR()=PureAdditive_Noise':
    // additiveR() returns the covariation matrix of the additive process noise,
    // nonAdditiveR() and SR_nonAdditiveR() make no sense.
    // ** in case 'typeR()=Heterogeneous_Noise':
    // nonAdditiveR() returns the covariation matrix of the non-additive process noise,
    // SR_nonAdditiveR() is nonAdditiveR()'s square root;
    // additiveQ() returns the covariation matrix of the additive process noise .
    //
    // we don't have a function named 'SR_additiveR()' corresponding to 'SR_addiive_Q()',
    // because we don't need that.
    ///////////////////////////////////////////////////////////////////
    Matrix additiveR() const;
    Matrix nonAdditiveR() const;
    //Matrix SR_additiveR() const;     // not needed.
    Matrix SR_nonAdditiveR() const;


protected:  ///// Manifold Address

    ManifoldMap* statusMap ;
    ManifoldMap* measureMap ;

    ///////////////////////////////////////////////////////////////////
    // autoF() is a shell for function 'f()'.
    // when 'statusMap' is valid, i.e. the status-space is a manifold, 'autoF()' allows
    // to input a point in tangent space directly, and automaticly map it to the manifold
    // before call function 'f()'.
    // when 'statusMap' is not valid, autoF() functions the same with f() ;
    //
    // autoH() is a shell for function 'h()'.
    // when 'statusMap' is valid, i.e. the status-space is a manifold, 'autoH()' allows
    // to input a point in tangent space directly, and automaticly map it to the manifold
    // before call function 'h()'.
    // when 'statusMap' is not valid, autoH() functions the same with h() ;
    ///////////////////////////////////////////////////////////////////
    Matrix autoF(const Matrix& tangent_Xk, const Matrix& Uk=Matrix(),
             const Matrix& nonAdditive_Vk=Matrix()) ;
    Matrix autoH(const Matrix& tangent_X, const Matrix& nonAdditive_Nk=Matrix()) ;


protected :

    ///////////////////////////////////////////////////////////////////
    // more than one R or Q or Posterior can be defined as candidates.
    // choose the active one with 'curR' or 'curQ' or curPosterior .
    ///////////////////////////////////////////////////////////////////
    NoiseDescrip R, Q;
    PosteriorStatus Posterior ;

    NoiseDescrip *curR;
    NoiseDescrip *curQ;
    PosteriorStatus *curPosterior ;

    friend class UKF ;
};


END_JK_KALMAN

#endif // UKF_H
